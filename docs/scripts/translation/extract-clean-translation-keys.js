#!/usr/bin/env node

/**
 * Improved Translation Key Extraction Tool
 * 
 * Focuses on legitimate translation keys and filters out noise:
 * - Hardcoded strings
 * - File paths and imports
 * - Variable interpolations
 * - Single characters and punctuation
 */

const fs = require('fs');
const path = require('path');

const TEMP_DIR = './temp_translation_analysis';
const SRC_DIR = './src';

// Ensure temp directory exists
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR);
}

// Language configuration
const LOCALES = ['en', 'cs'];
const NAMESPACES = ['admin', 'auth', 'common', 'dashboard', 'match', 'navigation', 'player', 'settings', 'statistics'];

console.log('üîç Starting improved translation key extraction...\n');

// 1. Extract legitimate translation keys only
function extractLegitimateTranslationKeys() {
  console.log('üìã Phase 1: Extracting legitimate translation keys...');
  
  // More sophisticated patterns to capture translation usage
  const patterns = [
    // useTranslations('namespace') calls
    /useTranslations\s*\(\s*['"`]([a-zA-Z][a-zA-Z0-9_-]*?)['"`]\s*\)/g,
    // t('key') calls - but filter out obvious noise
    /\bt\s*\(\s*['"`]([a-zA-Z][a-zA-Z0-9_.]+)['"`]\s*[,)]/g,
    // Translation hook calls with namespace
    /const\s+t\s*=\s*useTranslations\s*\(\s*['"`]([a-zA-Z][a-zA-Z0-9_-]*?)['"`]\s*\)/g
  ];
  
  const allKeys = new Set();
  const keysByFile = {};
  const keysByNamespace = {};
  const namespaceUsage = new Set();
  
  // Find all source files
  function findSourceFiles(dir) {
    const files = [];
    
    function walk(currentDir) {
      if (currentDir.includes('node_modules') || currentDir.includes('.next')) return;
      
      try {
        const items = fs.readdirSync(currentDir);
        
        for (const item of items) {
          const fullPath = path.join(currentDir, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
            walk(fullPath);
          } else if (stat.isFile() && (item.endsWith('.ts') || item.endsWith('.tsx')) && !item.endsWith('.d.ts')) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        console.warn(`   ‚ö†Ô∏è  Could not read directory ${currentDir}: ${error.message}`);
      }
    }
    
    walk(dir);
    return files;
  }
  
  const sourceFiles = findSourceFiles(SRC_DIR);
  console.log(`   Found ${sourceFiles.length} source files to analyze`);
  
  // Helper to validate if a key looks legitimate
  function isLegitimateKey(key) {
    if (!key || typeof key !== 'string') return false;
    if (key.length < 2) return false; // Too short
    if (key.length > 100) return false; // Too long, likely not a key
    if (key.includes('${')) return false; // Template literal
    if (key.includes('__')) return false; // Likely internal identifier
    if (key.includes('/')) return false; // Likely file path
    if (key.includes('@')) return false; // Likely import path
    if (/^[A-Z\s_]+$/.test(key)) return false; // All caps likely hardcoded string
    if (/^\d+$/.test(key)) return false; // Pure numbers
    if (/^[^\w]+$/.test(key)) return false; // Only punctuation
    if (key.includes('Page ') || key.includes('Generated by')) return false; // Hardcoded content
    if (key.startsWith('${') || key.endsWith('}')) return false; // Template parts
    
    return true;
  }
  
  for (const file of sourceFiles) {
    try {
      const content = fs.readFileSync(file, 'utf8');
      const relativeFile = path.relative(process.cwd(), file);
      const fileKeys = new Set();
      
      // Extract namespace usage from useTranslations calls
      const namespaceMatches = [...content.matchAll(/useTranslations\s*\(\s*['"`]([a-zA-Z][a-zA-Z0-9_-]*?)['"`]\s*\)/g)];
      for (const match of namespaceMatches) {
        const namespace = match[1];
        if (NAMESPACES.includes(namespace)) {
          namespaceUsage.add(namespace);
        }
      }
      
      // Extract t() calls and associate with known namespaces
      const tCallMatches = [...content.matchAll(/\bt\s*\(\s*['"`]([^'"`]+)['"`]/g)];
      for (const match of tCallMatches) {
        let key = match[1];
        
        if (!isLegitimateKey(key)) continue;
        
        // If key doesn't have namespace prefix, try to infer from file context
        if (!key.includes('.')) {
          // Look for namespace usage in the same file
          for (const ns of namespaceUsage) {
            if (content.includes(`useTranslations('${ns}')`)) {
              key = `${ns}.${key}`;
              break;
            }
          }
          // If no namespace found, assume common
          if (!key.includes('.')) {
            key = `common.${key}`;
          }
        }
        
        allKeys.add(key);
        fileKeys.add(key);
        
        // Extract namespace
        const namespace = key.includes('.') ? key.split('.')[0] : 'common';
        if (!keysByNamespace[namespace]) {
          keysByNamespace[namespace] = new Set();
        }
        keysByNamespace[namespace].add(key);
      }
      
      if (fileKeys.size > 0) {
        keysByFile[relativeFile] = Array.from(fileKeys);
      }
    } catch (error) {
      console.warn(`   ‚ö†Ô∏è  Could not read file ${file}: ${error.message}`);
    }
  }
  
  // Convert Sets to Arrays for JSON serialization
  const keysByNamespaceArray = {};
  for (const [namespace, keys] of Object.entries(keysByNamespace)) {
    keysByNamespaceArray[namespace] = Array.from(keys).sort();
  }
  
  // Write results
  fs.writeFileSync(
    path.join(TEMP_DIR, 'clean_translation_keys.txt'),
    Array.from(allKeys).sort().join('\n')
  );
  
  fs.writeFileSync(
    path.join(TEMP_DIR, 'clean_keys_by_file.json'),
    JSON.stringify(keysByFile, null, 2)
  );
  
  fs.writeFileSync(
    path.join(TEMP_DIR, 'clean_keys_by_namespace.json'),
    JSON.stringify(keysByNamespaceArray, null, 2)
  );
  
  console.log(`   ‚úÖ Extracted ${allKeys.size} legitimate translation keys`);
  console.log(`   üìä Distribution by namespace:`);
  for (const [namespace, keys] of Object.entries(keysByNamespaceArray)) {
    console.log(`      ${namespace}: ${keys.length} keys`);
  }
  
  return { allKeys: Array.from(allKeys), keysByNamespace: keysByNamespaceArray };
}

// 2. Load existing translations (reuse from previous script)
function loadExistingTranslations() {
  console.log('\nüìö Phase 2: Loading existing translation files...');
  
  const existingTranslations = {};
  
  for (const locale of LOCALES) {
    existingTranslations[locale] = {};
    
    for (const namespace of NAMESPACES) {
      const filePath = path.join(SRC_DIR, 'i18n', 'locales', locale, `${namespace}.json`);
      
      try {
        if (fs.existsSync(filePath)) {
          const content = fs.readFileSync(filePath, 'utf8');
          const translations = JSON.parse(content);
          existingTranslations[locale][namespace] = translations;
          
          // Count nested keys
          function countKeys(obj, prefix = '') {
            let count = 0;
            for (const [key, value] of Object.entries(obj)) {
              if (typeof value === 'string') {
                count++;
              } else if (typeof value === 'object' && value !== null) {
                count += countKeys(value, `${prefix}${key}.`);
              }
            }
            return count;
          }
          
          const keyCount = countKeys(translations);
          console.log(`   üìÑ ${locale}/${namespace}.json: ${keyCount} keys`);
        } else {
          console.log(`   ‚ùå Missing: ${locale}/${namespace}.json`);
          existingTranslations[locale][namespace] = {};
        }
      } catch (error) {
        console.warn(`   ‚ö†Ô∏è  Error loading ${locale}/${namespace}.json: ${error.message}`);
        existingTranslations[locale][namespace] = {};
      }
    }
  }
  
  return existingTranslations;
}

// 3. Identify truly missing keys
function identifyTrulyMissingKeys(calledKeys, existingTranslations) {
  console.log('\nüîç Phase 3: Identifying truly missing translation keys...');
  
  const missingKeys = {};
  const availableKeys = {};
  
  for (const locale of LOCALES) {
    missingKeys[locale] = {};
    availableKeys[locale] = {};
    
    for (const namespace of NAMESPACES) {
      missingKeys[locale][namespace] = [];
      availableKeys[locale][namespace] = [];
      
      // Get all keys that should be in this namespace
      const namespaceKeys = calledKeys.keysByNamespace[namespace] || [];
      
      for (const fullKey of namespaceKeys) {
        // Remove namespace prefix to get the actual key path
        const keyPath = fullKey.startsWith(`${namespace}.`) 
          ? fullKey.substring(namespace.length + 1)
          : fullKey;
        
        // Check if key exists in translation file
        const exists = checkKeyExists(existingTranslations[locale][namespace], keyPath);
        
        if (exists) {
          availableKeys[locale][namespace].push(fullKey);
        } else {
          missingKeys[locale][namespace].push(fullKey);
        }
      }
    }
  }
  
  // Helper function to check if nested key exists
  function checkKeyExists(obj, keyPath) {
    const keys = keyPath.split('.');
    let current = obj;
    
    for (const key of keys) {
      if (current && typeof current === 'object' && key in current) {
        current = current[key];
      } else {
        return false;
      }
    }
    
    return typeof current === 'string';
  }
  
  // Write results
  fs.writeFileSync(
    path.join(TEMP_DIR, 'clean_missing_keys.json'),
    JSON.stringify(missingKeys, null, 2)
  );
  
  fs.writeFileSync(
    path.join(TEMP_DIR, 'clean_available_keys.json'),
    JSON.stringify(availableKeys, null, 2)
  );
  
  // Summary
  console.log(`   üìä Missing keys summary:`);
  let totalMissing = 0;
  for (const locale of LOCALES) {
    console.log(`   ${locale.toUpperCase()}:`);
    for (const namespace of NAMESPACES) {
      const missing = missingKeys[locale][namespace].length;
      totalMissing += missing;
      if (missing > 0) {
        console.log(`      ${namespace}: ${missing} missing keys`);
      }
    }
  }
  console.log(`   üö® Total truly missing keys: ${totalMissing}`);
  
  return { missingKeys, availableKeys };
}

// 4. Generate focused summary report
function generateFocusedReport(calledKeys, missingKeys) {
  console.log('\nüìù Phase 4: Generating focused summary report...');
  
  const totalMissing = Object.values(missingKeys.en).reduce((sum, keys) => sum + keys.length, 0);
  const coverage = ((calledKeys.allKeys.length - totalMissing) / calledKeys.allKeys.length * 100).toFixed(1);
  
  const report = `# Clean Translation Key Analysis
Generated: ${new Date().toISOString()}

## Overview
- **Total Legitimate Translation Keys**: ${calledKeys.allKeys.length}
- **Total Missing Keys**: ${totalMissing}
- **Translation Coverage**: ${coverage}%
- **Supported Locales**: ${LOCALES.join(', ')}

## Key Distribution by Namespace
${Object.entries(calledKeys.keysByNamespace).map(([ns, keys]) => 
  `- **${ns}**: ${keys.length} keys (${missingKeys.en[ns].length} missing)`
).join('\n')}

## Critical Missing Keys by Namespace

${NAMESPACES.filter(ns => missingKeys.en[ns].length > 0).map(ns => `
### ${ns} namespace (${missingKeys.en[ns].length} missing keys)
${missingKeys.en[ns].slice(0, 10).map(key => `- ${key}`).join('\n')}
${missingKeys.en[ns].length > 10 ? `... and ${missingKeys.en[ns].length - 10} more` : ''}
`).join('')}

## Next Steps for Translation Restoration

### Immediate Action Required
1. **Focus on common namespace**: ${missingKeys.en.common.length} missing keys causing UI failures
2. **Fix match namespace**: ${missingKeys.en.match.length} missing keys breaking live scoring
3. **Complete statistics namespace**: ${missingKeys.en.statistics.length} missing keys for analytics

### Implementation Strategy
1. Add missing keys to English translation files first
2. Translate to Czech using professional tennis terminology
3. Test each namespace completion before moving to next
4. Implement translation validation in build process

---
*Generated by improved translation analysis tool - filtered legitimate keys only*
`;

  fs.writeFileSync(
    path.join(TEMP_DIR, 'CLEAN_TRANSLATION_REPORT.md'),
    report
  );
  
  console.log(`   ‚úÖ Generated focused analysis report`);
  console.log(`   üéØ True translation coverage: ${coverage}%`);
  
  return report;
}

// Main execution
async function main() {
  try {
    const calledKeys = extractLegitimateTranslationKeys();
    const existingTranslations = loadExistingTranslations();
    const { missingKeys, availableKeys } = identifyTrulyMissingKeys(calledKeys, existingTranslations);
    const report = generateFocusedReport(calledKeys, missingKeys);
    
    console.log('\nüéâ Clean translation key analysis completed!');
    console.log(`üìä Key Statistics:`);
    console.log(`   - Legitimate keys called: ${calledKeys.allKeys.length}`);
    const totalMissing = Object.values(missingKeys.en).reduce((sum, keys) => sum + keys.length, 0);
    console.log(`   - Actually missing keys: ${totalMissing}`);
    console.log(`   - Real coverage: ${((calledKeys.allKeys.length - totalMissing) / calledKeys.allKeys.length * 100).toFixed(1)}%`);
    
  } catch (error) {
    console.error('‚ùå Error during analysis:', error.message);
    process.exit(1);
  }
}

main();